{"version":3,"sources":["App.js","serviceWorker.js","components/Header/Header.jsx","components/Footer/Footer.jsx","components/Upload.jsx","views/Home.jsx","index.js"],"names":["UInt8ArrayToBase64","buffer","bin","i","length","String","fromCharCode","window","btoa","Component","Boolean","location","hostname","match","Header","Nav","style","backgroundColor","Navbar","expand","NavbarBrand","color","fontSize","Footer","className","Date","getFullYear","UploadImageComponent","props","handleChange","e","preventDefault","setState","message","target","value","handleEffectValueChange","imageMeta","state","effect","isProcessing","disabledEffect","a","handleManipulationTrigger","manipulatedImage","mod","inst","memoryByte","bytes","handleChangeStatus","bind","WebAssembly","instantiateStreaming","fetch","go","importObject","instance","module","memByte","Uint8Array","exports","mem","this","memoryBuff","run","status","meta","file","fileBlobURL","previewUrl","fetchBlobURL","blob","fileBlob","fileReader","FileReader","readAsArrayBuffer","onload","event","memBuf","result","imageBuff","image64","LoadAndProcessImage","byteLength","files","extras","reject","FormGroup","Label","for","Input","type","name","id","required","onChange","defaultValue","disabled","Container","fluid","Row","Col","md","sm","Card","CardHeader","CardBody","onChangeStatus","onSubmit","handleImageSubmit","accept","styles","previewImage","maxHeight","maxWidth","dropzone","height","inputLabel","extra","inputLabelWithFiles","inputContent","handleUploadTextChange","maxFiles","renderEffectsDropdown","Media","src","alt","width","HomeComponent","Upload","ReactDOM","render","Home","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7d04c936.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.css';\nimport { Card, CardHeader, CardBody, CardFooter, Media } from 'reactstrap'\nimport Dropzone from 'react-dropzone-uploader'\nimport 'react-dropzone-uploader/dist/styles.css'\n\n\n// this function coverts our array buffer of manipulated image to base64 to be used in the image component\n// thank you very much, stackoverflow.. saved me hours ü§ó\nfunction UInt8ArrayToBase64(buffer) {\n  let bin = ''\n  for (let i = 0; i < buffer.length; i++) {\n    bin += String.fromCharCode(buffer[i])\n  }\n  return window.btoa(bin)\n}\n\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      message: '',\n      mod: null,\n      inst: null,\n      memoryByte: null,\n      bytes: null,\n      manimage: '',\n      isProcessing: false\n    }\n\n    this.handleChangeStatus = this.handleChangeStatus.bind(this)\n  }\n\n  async componentDidMount() {\n    let { instance, module } = await WebAssembly.instantiateStreaming(fetch(\"main.wasm\"), window.go.importObject)\n    let memByte = new Uint8Array(instance.exports.mem.buffer)\n    // saving to state.. tsk tsk not sure its the most optimal but i guess it works?? also, the value isnt that \"big\" anyway\n    this.setState({\n      mod: module,\n      inst: instance,\n      memoryByte: memByte\n    })\n\n    window.memoryBuff = memByte\n    await window.go.run(instance)\n  }\n\n  handleChange = (e) => {\n    e.preventDefault();\n    this.setState({\n      message: e.target.value\n    })\n  }\n\n  handleSubmit = async (e) => {\n    e.preventDefault()\n    window.sayHelloJS(this.state.message)\n  }\n\n\n  handleUploadTextChange(files, extras) {\n    if (extras.reject) {\n      return `Images only`\n    }\n    return 'Upload an image'\n  }\n\n\n  async handleChangeStatus({ meta, file }, status) {\n\n    this.setState({\n      isProcessing: true\n    })\n    if (status === 'done') {\n      let fileBlobURL = meta.previewUrl\n      let fetchBlobURL = await fetch(fileBlobURL)\n      let fileBlob = await fetchBlobURL.blob()\n      let fileReader = new FileReader()\n      fileReader.readAsArrayBuffer(fileBlob)\n      fileReader.onload = event => {\n        let memBuf = new Uint8Array(event.target.result)\n        window.imageBuff = memBuf\n        let WasmManipulatedImage = window.loadImg(memBuf.length, memBuf)\n        let image64 = UInt8ArrayToBase64(WasmManipulatedImage)\n        this.setState({ manimage: image64, bytes: event.target.result.byteLength, isProcessing: false })\n      }\n    }\n  }\n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <form>\n          <input type=\"text\" name=\"\" id=\"userInput\" onChange={(e) => this.handleChange(e)} style={{ marginTop: '100px' }} />\n          <br />\n          <button type=\"submit\" onClick={(e) => this.handleSubmit(e)}>Click me to see MAGIC!!</button>\n        </form>\n        <br />\n        <span id=\"message\">\n          Ayomide Onigbinde wrote this!!üòâ...üíï from WebAssembly and Golang\n        </span>\n\n        <Card className='d-flex justify-content-center' style={{ marginTop: '10vh', marginLeft: '20%', marginRight: '20%', height: 350 }}>\n          <CardHeader style={{ color: 'black' }}>\n            Click Below to Upload an image to manipulate\n          </CardHeader>\n\n          <CardBody>\n            <Dropzone\n              onChangeStatus={this.handleChangeStatus}\n              onSubmit={this.handleImageSubmit}\n              accept='image/*'\n              styles={{ previewImage: { maxHeight: '70px', maxWidth: '70px' }, dropzone: { height: 200 }, inputLabel: (files, extra) => extra.reject ? {} : {}, inputLabelWithFiles: (files, extra) => { } }}\n              inputContent={this.handleUploadTextChange}\n              maxFiles={1}\n\n            />\n          </CardBody>\n\n          <CardFooter>\n\n          </CardFooter>\n        </Card>\n        <Card>\n          {this.state.isProcessing ? <span>Processing your image...</span> : (!this.state.manimage ? <span>Please Upload an Image. Manipulated image appears here</span> :\n            <Media src={`data:image/png;base64,${this.state.manimage}`} alt=\"\" style={{ height: '50%', width: '50%' }}></Media>)}\n        </Card>\n      </div>\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React, { Component } from 'react'\nimport { Nav, Navbar, NavItem, NavbarBrand } from 'reactstrap'\n\nclass Header extends Component {\n\n  render() {\n    return (\n      <div>\n        <Nav style={{ backgroundColor: \"#8960db\" }}>\n          <Navbar expand=\"md\">\n            <NavbarBrand style={{ color: \"white\", fontSize: \"35px\" }}>Y.A.I.M.P</NavbarBrand>\n          </Navbar>\n        </Nav>\n      </div>\n    )\n  }\n}\n\nexport default Header","import React, { Component } from 'react'\n\nclass Footer extends Component {\n    render() {\n        return (\n            <div>\n                <footer className=\"footer\">\n                    Made with ‚ù§Ô∏è &#9400; {`${new Date().getFullYear()}`}. &nbsp; Ayomide Onigbinde\n                </footer>\n            </div>\n        )\n    }\n}\n\nexport default Footer","import React, { Component } from \"react\";\nimport { Card, CardHeader, CardBody, CardFooter, Row, Col, Container, Media, FormGroup, Label, Input } from \"reactstrap\";\nimport Dropzone from 'react-dropzone-uploader'\nimport 'react-dropzone-uploader/dist/styles.css'\n\n\n// this function coverts our array buffer of manipulated image to base64 to be used in the image component\n// thank you very much, stackoverflow.. saved me hours ü§ó\nfunction UInt8ArrayToBase64(buffer) {\n  let bin = ''\n  for (let i = 0; i < buffer.length; i++) {\n    bin += String.fromCharCode(buffer[i])\n  }\n  return window.btoa(bin)\n}\n\n\nclass UploadImageComponent extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      manipulatedImage: '',\n      mod: null,\n      inst: null,\n      memoryByte: null,\n      bytes: null,\n      isProcessing: false,\n      effect: 'monochrome', // using monochrome as the default effect,\n      disabledEffect: true, // üí° an idea could be to make this reflexive of isProcessing i.e make it depend on the state of isProcessing instead of manually specifying the current state everywhere... dunno, just an idea. current implementationw works just great\n      imageMeta: null\n    }\n    this.handleChangeStatus = this.handleChangeStatus.bind(this)\n  }\n\n  async componentDidMount() {\n    let { instance, module } = await WebAssembly.instantiateStreaming(fetch(\"main.wasm\"), window.go.importObject)\n    let memByte = new Uint8Array(instance.exports.mem.buffer)\n    this.setState({\n      mod: module,\n      inst: instance,\n      memoryByte: memByte\n    })\n\n    window.memoryBuff = memByte\n    await window.go.run(instance)\n  }\n\n  // handleChangeStatus method handles the conversion of our image to UInt8Array which we pass to the WebAssembly exported function that applies the effect we want\n  async handleChangeStatus({ meta, file }, status) {\n\n    this.setState({\n      isProcessing: true\n    })\n    if (status === 'done') {\n      this.setState({ isProcessing: false, disabledEffect: false, imageMeta: meta })\n    } else if (status === 'removed') {\n      this.setState({ isProcessing: false })\n    }\n  }\n\n  async handleManipulationTrigger(meta) {\n    let fileBlobURL = meta.previewUrl\n    let fetchBlobURL = await fetch(fileBlobURL)\n    let fileBlob = await fetchBlobURL.blob()\n    let fileReader = new FileReader()\n    fileReader.readAsArrayBuffer(fileBlob)\n    fileReader.onload = event => {\n      let memBuf = new Uint8Array(event.target.result)\n      window.imageBuff = memBuf\n      let WasmManipulatedImage = window.LoadAndProcessImage(memBuf.length, this.state.effect, memBuf)\n      let image64 = UInt8ArrayToBase64(WasmManipulatedImage)\n      this.setState({ manipulatedImage: image64, bytes: event.target.result.byteLength, isProcessing: false, disabledEffect: false })\n    }\n  }\n  // changes the message text of the Dropzone upload component\n  handleUploadTextChange(files, extras) {\n    if (extras.reject) {\n      return `Images only`\n    }\n    return 'Upload an image'\n  }\n\n  handleChange = (e) => {\n    e.preventDefault();\n    this.setState({\n      message: e.target.value\n    })\n  }\n\n  handleEffectValueChange = e => {\n    let value = e.target.value\n    let { imageMeta } = this.state\n    this.setState({ effect: value, isProcessing: true, disabledEffect: true }, async () => {\n      this.handleManipulationTrigger(imageMeta)\n    })\n  }\n\n  renderEffectsDropdown() {\n    return (\n      <div>\n        <FormGroup>\n          <Label for=\"select\">Effect</Label>\n          <Input type=\"select\" name=\"select\" id=\"effectselect\" required onChange={e => this.handleEffectValueChange(e)} defaultValue=\"\" disabled={this.state.disabledEffect}>\n            <option value=\"\">Select</option>\n            <option value=\"monochrome\">Monochrome</option>\n            <option value=\"half-monochrome\">Half Monochrome</option>\n            <option value=\"sepia\">Sepia</option>\n          </Input>\n        </FormGroup>\n      </div>\n    )\n  }\n\n  render() {\n    const { manipulatedImage, isProcessing } = this.state\n    return (\n      <div className=\"images-container\">\n        <Container fluid={true}>\n          <Row>\n            <Col md={6} sm={12}>\n              <Card>\n                <CardHeader>\n                  <span>Please Upload your image here</span>\n                </CardHeader>\n              </Card>\n              <CardBody>\n                <Dropzone\n                  onChangeStatus={this.handleChangeStatus}\n                  onSubmit={this.handleImageSubmit}\n                  accept='image/png'\n                  styles={{ previewImage: { maxHeight: '70px', maxWidth: '70px' }, dropzone: { height: 200 }, inputLabel: (files, extra) => extra.reject ? {} : {}, inputLabelWithFiles: (files, extra) => { } }}\n                  inputContent={this.handleUploadTextChange}\n                  maxFiles={1}\n                />\n              </CardBody>\n              {this.renderEffectsDropdown()}\n            </Col>\n\n            <Col>\n              <Card>\n                <CardHeader>\n                  <span>Output of your effect</span>\n                </CardHeader>\n              </Card>\n              <CardBody>\n                {isProcessing ? <span>Processing your image...</span> : (!manipulatedImage ? <span>Please Upload an Image. Manipulated image appears here</span> :\n                  <Media src={`data:image/png;base64,${manipulatedImage}`} alt=\"\" style={{ height: '100%', width: '100%' }}></Media>)}\n              </CardBody>\n            </Col>\n          </Row>\n        </Container>\n      </div>\n    )\n  }\n}\n\nexport default UploadImageComponent","import React, { Component } from 'react'\nimport Header from '../components/Header/Header'\nimport { Card, CardHeader } from 'reactstrap'\nimport Footer from '../components/Footer/Footer'\nimport UploadImageComponent from '../components/Upload'\n\nclass HomeComponent extends Component {\n  render() {\n    return (\n      <div>\n        <Header />\n        {/* <div>\n          <Card>\n            <CardHeader>\n              <span>Hello there!!</span>\n            </CardHeader>\n          </Card>\n        </div> */}\n\n        {/* <div className=\"container\"> */}\n        <UploadImageComponent />\n        {/* </div> */}\n\n        <div>\n          <Footer />\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default HomeComponent","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport HomeComponent from './views/Home';\n\nReactDOM.render(<HomeComponent />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}